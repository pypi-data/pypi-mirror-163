# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['vivify']

package_data = \
{'': ['*']}

install_requires = \
['typing-inspect>=0.7.1,<0.8.0']

setup_kwargs = {
    'name': 'vivify',
    'version': '1.0.0',
    'description': 'A Python library for using INI files to instantiate classes.',
    'long_description': '# Vivify\n\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)\n[![Keep a Changelog v1.1.0 badge](https://img.shields.io/badge/changelog-Keep%20a%20Changelog%20v1.1.0-%23E05735)](./CHANGELOG.md)\n[![Contributor Covenant](https://img.shields.io/badge/Contributor%20Covenant-2.1-4baaaa.svg)](code_of_conduct.md)\n[![Conventional Commits](https://img.shields.io/badge/Conventional%20Commits-1.0.0-%23FE5196?logo=conventionalcommits&logoColor=white)](https://conventionalcommits.org)\n[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n[![img](https://img.shields.io/badge/semver-2.0.0-green)](https://semver.org/)\n\n## Overview\n\nVivify is a lightweight Python library for INI style object initialisation. Using Vivify, you can instantiate classes and set attributes using values provided from an external configuration. Vivify supports both POD types as well as more complex objects and relationships. This is particularly useful in domains where the configuration is very closely coupled to the objects.\n\n## Installation\n\nInstalling Vivify is easy! Vivify is available on the Python Packaging Index. If you\'re using Poetry then `poetry add vivify`, otherwise:\n\n```shell\npip install vivify\n```\n\n## Usage\n\nThe snippets shown below are provided in full in the [examples directory](./examples/README.md) and demonstrate using an external configuration to instantiate some pre-defined classes. Further examples are also supplied in the examples directory.\n\nThis example showcases how Vivify supports complex relationships between classes. In this case, there is a bidirectional associative relationship between classes `A` and `B` and `B` has an additional variable of type `V`.\n\n```python\nclass V(list[int], Vivifiable):\n    @classmethod\n    def vivify(cls, object):\n        return cls(map(int, object.split(",")))\n\n\nclass A(object):\n    b: B\n\n\nclass B(object):\n    a: A\n    v: V\n```\n\nNote that in the code above we should specify the types of any instance variables. This is so that Vivify can instantiate the correct type for a specified variable, e.g. to distinguish between a string and a reference to another object in the configuration. It is also important that any attributes specified in the configuration should be settable (or at the very least an attempt to set the attribute should not fail).\n\nThe following configuration INI file (`example.ini`) contains the options we want to use to instantiate two instances of these classes named `foo` and `bar`.\n\n```ini\n[main]\nfoo = A\nbar = B\n\n[foo]\ni = 1\nb = bar\n\n[bar]\na = foo\nv = 1, 2, 3\n```\n\nThe `main` section where variables are named can be given any valid section name other than that which is reserved for supplying default values for sections - this is defined as `"DEFAULT"` in the standard [configuration file parsing library](https://docs.python.org/3/library/configparser.html). Note how the other section names correspond to the variable names provided in the `main` section.\n\n```python\n# initialise the config parser and read the ini file\nconfig = ConfigParser()\nwith open("example.ini") as f:\n    config.read_file(f)\n\n# specify the valid objects for vivification\nvivifier = Vivifier(types=[A, B])\nvivified = vivifier.vivify(instances="main", config=config)\n```\n\n```python\n# verify that the vivification occurred as expected\nassert isinstance(vivified["foo"], A)\nassert isinstance(vivified["bar"], B)\nassert vivified["foo"].b == vivified["bar"]\nassert vivified["bar"].a == vivified["foo"]\nassert vivified["bar"].v == [1, 2, 3]\n```\n\n## Limitations\n\nMost simple cases should work without issue. Things get complicated and more care should be taken when there are multiple possible types for a value. Consider an attribute with the type annotation `Union[list[int], Optional[str]]`. With a configuration value of `None`, there are two possible ways this could be interpreted: (i) `None`, and (ii) `"None"` (because `str(None)` returns `"None"`). The `list[int]` annotation will be skipped because it is a parameterised generic and cannot be instantiated. Currently, the actual type chosen for the is entirely dependent on the ordering of the result of a call to `get_args` from the [typing extensions](https://github.com/python/typing_extensions) library. The first valid matching type is picked for setting the attributes value.\n\n```python\nfrom typing import Optional, Union\nfrom typing_extensions import get_args\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format="%(asctime)s [%(levelname)s] %(message)s",\n    handlers=[logging.StreamHandler(sys.stdout)],\n)\n\nassert (\n    str(get_args(Union[list[int], Optional[str]]))\n    == "(list[int], <class \'str\'>, <class \'NoneType\'>)"\n)\n```\n\nIn this case, the value would be set to the string `"None"` because this matches first (after the invalid `list[int]`) and the permissive `str` type coercion accepts None as an argument.\n\nIf you are especially concerned about which type is used then it is a good idea to either make the typing more strict or use `Vivifiable` objects (preferred approaches) or alternatively check a call to `get_args` yourself on the type to verify that the implementation will work as you expect. Vivify provides extensive logging so you can see how variables are handled internally.\n\n## Licence\n\nCopyright [Adam D Walker](mailto:adam@wlkr.dev)\n\nLicensed under the Apache License, Version 2.0 (the "License");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-2.0>\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an "AS IS" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n',
    'author': 'Adam David Walker',
    'author_email': 'adam@wlkr.dev',
    'maintainer': 'Adam David Walker',
    'maintainer_email': 'adam@wlkr.dev',
    'url': 'https://github.com/wlkr/vivify',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.9,<4.0',
}


setup(**setup_kwargs)
