# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_core.ipynb.

# %% auto 0
__all__ = ['property_type', 'attributes', 'write_to_file', 'isNotEmpty', 'test_type', 'test_res', 'test_fail_u', 'test',
           'isEfuse', 'isX', 'isW', 'isY', 'isFT_checksum', 'Content']

# %% ../00_core.ipynb 2
from pathlib import Path
import tempfile

# %% ../00_core.ipynb 3
def write_to_file(content):
    dest = Path(tempfile.mkdtemp())
    filename = 'tmp'
    with open(dest / filename, 'w') as f:
        f.write(content)

    return dest / filename

def isNotEmpty(r):
    return len(r) != 0




# %% ../00_core.ipynb 5
from Semi_ATE import STDF

# %% ../00_core.ipynb 6
@property
def test_type(self):
    return self.fields['TEST_TXT']['Value']

@property
def test_res(self):
    return self.fields['RESULT']['Value']

@property
def test_fail_u(self):
    return self.fields['RESULT']['Value'] > self.fields['HI_LIMIT']['Value']

@property
def test(self):
    return {k: v['Value'] for k, v in self.fields.items()}

@property
def isEfuse(self):
    return 'eFuse' in self.test_type

@property
def isX(self):
    return self.isEfuse and ('X_coord' in self.test_type)

@property
def isW(self):
    return self.isEfuse and ('Wafer_number' in self.test_type)

@property
def isY(self):
    return self.isEfuse and ('Y_coord' in self.test_type)

@property
def isFT_checksum(self):
    return self.isEfuse and ('FT_checksum'  in self.test_type)

# bind attributes
property_type = type(test_type)
attributes = [test_type, test_res, test_fail_u,  test, isW, isY, isX, isEfuse, isFT_checksum]
for a in attributes:
    name = a.fget.__name__ if isinstance(a, property_type) else a.__name__
    setattr(STDF.PTR, name, a)

# %% ../00_core.ipynb 8
import pandas as pd
import tempfile
from pathlib import Path
from Semi_ATE import STDF

# %% ../00_core.ipynb 9
class Content:
    "for extracting wxy"
    def __init__(self, 
        data): # data as dict with fields 'stdf' and 'csv'
        self._stdf = data['stdf']
        self._csv = data['csv']

    @property
    def wxy(self) -> pd.DataFrame:
        self._f = write_to_file(self._stdf)
        self._parse_records()
        self._extract_wxy()
        self._add_cols()
        return self._dfs

    @property
    def csv(self):
        pass

    def _parse_records(self, record_type=STDF.PTR):
        self._recs = [r for r in STDF.records_from_file(str(self._f)) if isinstance(r, record_type)]

    def _extract_wxy(self):
        res,N,isHydrated = [],len(self._recs),[]
        cache,m ={},0
        dfs = []

        def updateCache():
            if r.isW: cache['w'] = int(r.test_res)
            if r.isX: cache['x'] = int(r.test_res)
            if r.isY: cache['y'] = int(r.test_res)

        for indx,r in enumerate(self._recs[::-1]): #begin from the end
            res.append((self._f.stem, indx, r.test_type, r.test['RESULT'], r.test['LO_LIMIT'], r.test['HI_LIMIT']))
            updateCache()
            if (r.isFT_checksum or indx == N-1) and isNotEmpty(cache):
                s = slice(m, indx + 1) if indx == N-1 else slice(m, indx) #if last item (reading backwards)
                wxy = cache['w'], cache['x'], cache['y']
                res[s] = [_r + wxy for _r in res[s]]
                cache,m = {},indx
                isHydrated.append(True)

        if any(isHydrated):
            columns = ['filename', 'indx', 'test_name','test_value',
                    'test_lo_limit', 'test_hi_limit', 'wafer_number', 'x_coord', 'y_coord']
            dfs.append(pd.DataFrame(res, columns=columns) )

        self._dfs = pd.concat(dfs)


    def _add_cols(self):
        def extract():
            qs_smt = r'.+(SMT\d).+'  # '\d' matches only single digit
            qs_lot = r'.*(K4.+GF).+' # '*' means could be nothing
            qs_date = r'.+_(220[5-7][0-9]{2}).+' ##very specific date search 2205... or 2206...
            qs_time = r'.+_220[5-7][0-9]{2}_?([0-9]{6}).+' #'?'=='optional'

            self._dfs['test_insertion'] = self._dfs.filename.str.extract(qs_smt).values
            self._dfs['lot'] = self._dfs.filename.str.extract(qs_lot).values
            self._dfs['date'] = self._dfs.filename.str.extract(qs_date).values
            self._dfs['time'] = self._dfs.filename.str.extract(qs_time).values

        def gen_cols():
            self._dfs['test_value_minus_test_hi_limit'] = self._dfs['test_value'] - self._dfs['test_hi_limit']
            self._dfs['test_lo_limit_minus_test_value'] = self._dfs['test_lo_limit'] - self._dfs['test_value']
            self._dfs['wxy'] = self._dfs['wafer_number'].astype('str') + \
                    '/' + self._dfs['x_coord'].astype('str') + '/' + self._dfs['y_coord'].astype('str')

        extract()
        gen_cols()

# %% ../00_core.ipynb 11
show_doc(Content)
