# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['filterbox', 'filterbox.concurrent', 'filterbox.frozen', 'filterbox.mutable']

package_data = \
{'': ['*']}

install_requires = \
['cykhash>=2.0.0,<3.0.0',
 'numpy>=1.14,<2.0',
 'readerwriterlock>=1.0.9,<2.0.0',
 'sortednp>=0.4.0,<0.5.0']

setup_kwargs = {
    'name': 'filterbox',
    'version': '0.9.4',
    'description': 'Finds Python objects by attribute value',
    'long_description': '# FilterBox\n\nContainer for finding Python objects.\n\nStores objects by their attribute value. Uses B-tree indexes to make finding very fast.\n\n[![tests Actions Status](https://github.com/manimino/filterbox/workflows/tests/badge.svg)](https://github.com/manimino/filterbox/actions)\n[![Coverage - 100%](https://img.shields.io/static/v1?label=Coverage&message=100%&color=2ea44f)](test/cov.txt)\n[![license - MIT](https://img.shields.io/static/v1?label=license&message=MIT&color=2ea44f)](/LICENSE)\n![python - 3.7+](https://img.shields.io/static/v1?label=python&message=3.7%2B&color=2ea44f)\n\n\n### Install\n\n```\npip install filterbox\n```\n\n### Usage\n\nFind a good day for flying a kite. It needs to have sunny skies and a wind speed between 5 and 10.\n\n```\nfrom filterbox import FilterBox\n\ndays = [\n    {\'day\': \'Saturday\', \'sky\': \'sunny\', \'wind_speed\': 1},\n    {\'day\': \'Sunday\', \'sky\': \'rainy\', \'wind_speed\': 3},\n    {\'day\': \'Monday\', \'sky\': \'sunny\', \'wind_speed\': 7},\n    {\'day\': \'Tuesday\', \'sky\': \'rainy\', \'wind_speed\': 9},\n    {\'day\': \'Wednesday\', \'sky\': \'sunny\', \'wind_speed\': 25}\n]\n\n# make a FilterBox\nfb = FilterBox(               # make a FilterBox\n    days,                     # add objects of any Python type\n    on=[\'sky\', \'wind_speed\']  # attributes to find by\n)\n\nfb.find({\n    \'sky\': \'sunny\', \n    \'wind_speed\': {\'>=\': 5, \'<=\': 10}\n})  \n# result: [{\'day\': \'Monday\', \'sky\': \'sunny\', \'wind_speed\': 7}]\n```\n\nYou can also find objects by functions evaluated on the object. \n\nFind palindromes of length 5 or 7:\n```\nfrom filterbox import FilterBox\nstrings = [\'bob\', \'fives\', \'kayak\', \'stats\', \'pullup\', \'racecar\']\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\nfb = FilterBox(strings, [is_palindrome, len])\nfb.find({\n    is_palindrome: True, \n    len: {\'in\': [5, 7]}\n})\n# result: [\'kayak\', \'racecar\', \'stats\']\n```\n\nFunctions are evaluated only once, when the object is added to the FilterBox. \n\n### Classes\n\n - `FilterBox` - can add, remove, and update objects after creation.\n - `ConcurrentFilterBox` - Thread-safe version of FilterBox. \n - `FrozenFilterBox` - Cannot be changed after creation. Fastest finds, lower memory usage, and thread-safe.\n\nAll three can be pickled using `filterbox.save()` / `filterbox.load()`.\n\n## More Examples\n\nExpand for sample code.\n\n<details>\n<summary>Exclude values</summary>\n<br>\n\n`find()` takes two arguments, `match` and `exclude`. The examples up to this point have used `match` only, but\n`exclude` works the same way.\n\n\n```\nfrom filterbox import FilterBox\n\nobjects = [\n    {\'item\': 1, \'size\': 10, \'flavor\': \'melon\'}, \n    {\'item\': 2, \'size\': 10, \'flavor\': \'lychee\'}, \n    {\'item\': 3, \'size\': 20, \'flavor\': \'peach\'},\n    {\'item\': 4, \'size\': 30, \'flavor\': \'apple\'}\n]\n\nfb = FilterBox(objects, on=[\'size\', \'flavor\'])\n\nfb.find(\n    match={\'size\': {\'<\': 30}},                       # match anything with size < 30\n    exclude={\'flavor\': {\'in\': [\'lychee\', \'peach\']}}  # where flavor is not in [\'lychee\', \'peach\']\n)  \n# result: [{\'item\': 1, \'size\': 10, \'flavor\': \'melon\'}]\n```\n\nIf `match` is unspecified, all objects will match, which allows filtering solely by `exclude`. Try removing \nthe `match` line in the example above.\n\n</details>\n\n<details>\n<summary>Access nested data using functions</summary>\n<br />\nUse functions to get values from nested data structures.\n\n```\nfrom filterbox import FilterBox\n\nobjs = [\n    {\'a\': {\'b\': [1, 2, 3]}},\n    {\'a\': {\'b\': [4, 5, 6]}}\n]\n\ndef get_nested(obj):\n    return obj[\'a\'][\'b\'][0]\n\nfb = FilterBox(objs, [get_nested])\nfb.find({get_nested: 4})  \n# result: {\'a\': {\'b\': [4, 5, 6]}}\n```\n</details>\n\n<details>\n<summary>Handle missing attributes</summary>\n<br />\n\nObjects don\'t need to have every attribute.\n\n - Objects that are missing an attribute will not be stored under that attribute. This saves lots of memory.\n - To find all objects that have an attribute, match the special value <code>ANY</code>. \n - To find objects missing the attribute, exclude <code>ANY</code>.\n - In functions, raise <code>MissingAttribute</code> to tell FilterBox the object is missing.\n\nExample:\n```\nfrom filterbox import FilterBox, ANY\nfrom filterbox.exceptions import MissingAttribute\n\nobjs = [{\'a\': 1}, {\'a\': 2}, {}]\n\ndef get_a(obj):\n    try:\n        return obj[\'a\']\n    except KeyError:\n        raise MissingAttribute  # tell FilterBox this attribute is missing\n\nfb = FilterBox(objs, [\'a\', get_a])\n\nfb.find({\'a\': ANY})          # result: [{\'a\': 1}, {\'a\': 2}]\nfb.find({get_a: ANY})        # result: [{\'a\': 1}, {\'a\': 2}]\nfb.find(exclude={\'a\': ANY})  # result: [{}]\n```\n\nNote that `None` is treated as a normal value and is stored.\n</details>\n\n### Recipes\n \n - [Auto-updating](https://github.com/manimino/filterbox/blob/main/examples/update.py) - Keep FilterBox updated when objects change\n - [Wordle solver](https://github.com/manimino/filterbox/blob/main/examples/wordle.ipynb) - Solve string matching problems faster than regex\n - [Collision detection](https://github.com/manimino/filterbox/blob/main/examples/collision.py) - Find objects based on type and proximity (grid-based)\n - [Percentiles](https://github.com/manimino/filterbox/blob/main/examples/percentile.py) - Find by percentile (median, p99, etc.)\n\n____\n\n## How it works\n\nFor each attribute in the FilterBox, it holds a tree that maps every unique value to the set of objects with \nthat value. \n\nThis is a rough idea of the data structure: \n```\nclass FilterBox:\n    indexes = {\n        \'attribute1\': BTree({10: set(some_obj_ids), 20: set(other_obj_ids)}),\n        \'attribute2\': BTree({\'abc\': set(some_obj_ids), \'def\': set(other_obj_ids)}),\n    }\n    \'obj_map\': {obj_ids: objects}\n}\n```\n\nDuring `find()`, the object ID sets matching each query value are retrieved. Then set operations like `union`, \n`intersect`, and `difference` are applied to get the matching object IDs. Finally, the object IDs are converted\nto objects and returned.\n\nIn practice, FilterBox and FrozenFilterBox have a bit more to them, as they are optimized to have much better\nmemory usage and speed than a naive implementation. \n\nSee the "how it works" pages for more detail:\n - [How FilterBox works](filterbox/mutable/how_it_works.md)\n - [How ConcurrentFilterBox works](filterbox/concurrent/how_it_works.md)\n - [How FrozenFilterBox works](filterbox/frozen/how_it_works.md)\n\n### API Reference:\n\n - [FilterBox API](https://filterbox.readthedocs.io/en/latest/filterbox.mutable.html#filterbox.mutable.main.FilterBox)\n - [ConcurrentFilterBox API](https://filterbox.readthedocs.io/en/latest/filterbox.concurrent.html#filterbox.concurrent.main.ConcurrentFilterBox)\n - [FrozenFilterBox API](https://filterbox.readthedocs.io/en/latest/filterbox.frozen.html#filterbox.frozen.main.FrozenFilterBox)\n\n\n### Why not SQLite?\n\nSQLite is an awesome relational database, and its in-memory storage option allows it to be used as a Python object \ncontainer. For example, [LiteBox](https://github.com/manimino/litebox) is a container that uses \nSQLite as an index. This is popular, and works fairly well.\n\nBut if you don\'t need a database - and only need to find Python objects - FilterBox is far superior.\n\nThe FilterBox containers have many advantages over SQLite:\n- They are faster. [Finding objects using FilterBox can be 5-10x faster than SQLite.](https://github.com/manimino/filterbox/blob/main/examples/perf_demo.ipynb)\n- They use sparse representations. Objects do not need to fill in "NULL" for missing attributes,\nthose attributes are simply not stored.\n- They can query any Python data type, not just numbers and strings. While there are tricks to get around this in \nSQLite, those tricks incur other costs in flexibility, complexity, and/or speed.\n- There is no need to translate datatypes (serialize / deserialize), allowing much faster finds.\n- FrozenFilterBox is immutable, and so implements optimizations that are not possible in SQLite.\n- They are much simpler. You\'ll never worry about whether you\'ve VACUUMed a FilterBox.\n\n____\n',
    'author': 'Theo Walker',
    'author_email': 'theo.ca.walker@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/manimino/filterbox/',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
