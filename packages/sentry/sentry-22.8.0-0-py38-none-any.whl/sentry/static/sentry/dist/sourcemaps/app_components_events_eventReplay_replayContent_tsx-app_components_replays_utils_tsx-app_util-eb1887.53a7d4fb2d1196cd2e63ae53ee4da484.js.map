{"version":3,"file":"chunks/app_components_events_eventReplay_replayContent_tsx-app_components_replays_utils_tsx-app_util-eb1887.xxxxxxxxxxxxxxxxxxxx.js","mappings":"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","sources":["webpack:///./app/components/events/eventReplay/replayContent.tsx","webpack:///./app/utils/replays/highlightNode.tsx","webpack:///./app/components/replays/replayContext.tsx","webpack:///./app/utils/replays/hooks/useRAF.tsx","webpack:///./app/components/replays/utils.tsx","webpack:///./app/utils/replays/hooks/useDiscoveryQuery.tsx"],"sourcesContent":["import styled from '@emotion/styled';\n\nimport DateTime from 'sentry/components/dateTime';\nimport Duration from 'sentry/components/duration';\nimport Placeholder from 'sentry/components/placeholder';\nimport {Provider as ReplayContextProvider} from 'sentry/components/replays/replayContext';\nimport ReplayView from 'sentry/components/replays/replayView';\nimport {t} from 'sentry/locale';\nimport space from 'sentry/styles/space';\nimport useFullscreen from 'sentry/utils/replays/hooks/useFullscreen';\nimport useReplayData from 'sentry/utils/replays/hooks/useReplayData';\nimport FluidHeight from 'sentry/views/replays/detail/layout/fluidHeight';\n\ntype Props = {\n  eventSlug: string;\n  orgId: string;\n};\n\nfunction ReplayContent({eventSlug, orgId}: Props) {\n  const {fetching, replay, fetchError} = useReplayData({\n    eventSlug,\n    orgId,\n  });\n  const {ref: fullscreenRef, toggle: toggleFullscreen} = useFullscreen();\n\n  const replayRecord = replay?.getReplay();\n  const replayEvent = replay?.getEvent();\n\n  if (fetchError) {\n    throw new Error('Failed to load Replay');\n  }\n\n  if (fetching || !replayRecord || !replayEvent) {\n    return <StyledPlaceholder height=\"400px\" width=\"100%\" />;\n  }\n\n  return (\n    <table className=\"table key-value\">\n      <tbody>\n        <tr key=\"replay\">\n          <td className=\"key\">{t('Replay')}</td>\n          <td className=\"value\">\n            <ReplayContextProvider replay={replay} initialTimeOffset={0}>\n              <PlayerContainer ref={fullscreenRef}>\n                <ReplayView toggleFullscreen={toggleFullscreen} showAddressBar={false} />\n              </PlayerContainer>\n            </ReplayContextProvider>\n          </td>\n        </tr>\n        <tr key=\"id\">\n          <td className=\"key\">{t('Id')}</td>\n          <td className=\"value\">\n            <pre className=\"val-string\">{replayRecord.replayId}</pre>\n          </td>\n        </tr>\n        <tr key=\"url\">\n          <td className=\"key\">{t('URL')}</td>\n          <td className=\"value\">\n            <pre className=\"val-string\">{replayEvent.culprit}</pre>\n          </td>\n        </tr>\n        <tr key=\"timestamp\">\n          <td className=\"key\">{t('Timestamp')}</td>\n          <td className=\"value\">\n            <pre className=\"val-string\">\n              <DateTime year seconds utc date={replayRecord.startedAt} />\n            </pre>\n          </td>\n        </tr>\n        <tr key=\"duration\">\n          <td className=\"key\">{t('Duration')}</td>\n          <td className=\"value\">\n            <pre className=\"val-string\">\n              <Duration seconds={replayRecord.duration / 1000} fixedDigits={0} />\n            </pre>\n          </td>\n        </tr>\n      </tbody>\n    </table>\n  );\n}\n\nconst PlayerContainer = styled(FluidHeight)`\n  margin-bottom: ${space(2)};\n  background: ${p => p.theme.background};\n`;\n\nconst StyledPlaceholder = styled(Placeholder)`\n  margin-top: ${space(2)};\n`;\n\nexport default ReplayContent;\n","import type {Replayer} from 'rrweb';\n\nconst DEFAULT_HIGHLIGHT_COLOR = 'rgba(168, 196, 236, 0.75)';\n\nconst highlightsByNodeId: Map<number, {canvas: HTMLCanvasElement}> = new Map();\n\ninterface AddHighlightParams {\n  nodeId: number;\n  replayer: Replayer;\n  annotation?: string;\n  color?: string;\n}\n\ninterface RemoveHighlightParams {\n  nodeId: number;\n  replayer: Replayer;\n}\n\ninterface ClearAllHighlightsParams {\n  replayer: Replayer;\n}\n\nexport function clearAllHighlights({replayer}: ClearAllHighlightsParams) {\n  for (const nodeId of highlightsByNodeId.keys()) {\n    removeHighlightedNode({replayer, nodeId});\n  }\n}\n\n/**\n * Remove the canvas that has the highlight for a node.\n *\n * XXX: This is potentially not good if we have a lot of highlights, as we\n * are creating a new canvas PER highlight.\n */\nexport function removeHighlightedNode({replayer, nodeId}: RemoveHighlightParams) {\n  if (!highlightsByNodeId.has(nodeId)) {\n    return false;\n  }\n\n  const highlightObj = highlightsByNodeId.get(nodeId);\n\n  if (!highlightObj || !replayer.wrapper.contains(highlightObj.canvas)) {\n    return false;\n  }\n\n  replayer.wrapper.removeChild(highlightObj.canvas);\n  highlightsByNodeId.delete(nodeId);\n\n  return true;\n}\n\n/**\n * Attempt to highlight the node inside of a replay recording\n */\nexport function highlightNode({\n  replayer,\n  nodeId,\n  annotation = '',\n  color,\n}: AddHighlightParams) {\n  // @ts-expect-error mouseTail is private\n  const {mouseTail, wrapper} = replayer;\n  const mirror = replayer.getMirror();\n  const node = mirror.getNode(nodeId);\n\n  // TODO(replays): There is some sort of race condition here when you \"rewind\" a replay,\n  // mirror will be empty and highlight does not get added because node is null\n  if (!node || !replayer.iframe.contentDocument?.body?.contains(node)) {\n    return null;\n  }\n\n  // @ts-ignore This builds locally, but fails in CI -- ignoring for now\n  const {top, left, width, height} = node.getBoundingClientRect();\n  const highlightColor = color ?? DEFAULT_HIGHLIGHT_COLOR;\n\n  // Clone the mouseTail canvas as it has the dimensions and position that we\n  // want on top of the replay. We may need to revisit this strategy as we\n  // create a new canvas for every highlight. See additional notes in\n  // removeHighlight() method.\n  const canvas = mouseTail.cloneNode();\n\n  const ctx = canvas.getContext('2d');\n\n  if (!ctx) {\n    return null;\n  }\n\n  // TODO(replays): Does not account for scrolling (should we attempt to keep highlight visible, or does it disappear)\n\n  // Draw a rectangle to highlight element\n  ctx.fillStyle = highlightColor;\n  ctx.fillRect(left, top, width, height);\n\n  // Draw a dashed border around highlight\n  ctx.beginPath();\n  ctx.setLineDash([5, 5]);\n  ctx.moveTo(left, top);\n  ctx.lineTo(left + width, top);\n  ctx.lineTo(left + width, top + height);\n  ctx.lineTo(left, top + height);\n  ctx.closePath();\n  ctx.stroke();\n\n  ctx.font = '24px Rubik';\n  ctx.textAlign = 'right';\n  ctx.textBaseline = 'bottom';\n\n  const textWidth = ctx.measureText(annotation).width;\n\n  // Draw rect around text\n  ctx.fillStyle = 'rgba(30, 30, 30, 0.75)';\n  ctx.fillRect(left + width - textWidth, top + height - 30, textWidth, 30);\n\n  // Draw text\n  ctx.fillStyle = 'white';\n  ctx.fillText(annotation, left + width, top + height);\n\n  highlightsByNodeId.set(nodeId, {\n    canvas,\n  });\n\n  wrapper.insertBefore(canvas, mouseTail);\n\n  return {\n    canvas,\n  };\n}\n","import React, {useCallback, useContext, useEffect, useRef, useState} from 'react';\nimport {useTheme} from '@emotion/react';\nimport {Replayer, ReplayerEvents} from 'rrweb';\n\nimport {\n  clearAllHighlights,\n  highlightNode,\n  removeHighlightedNode,\n} from 'sentry/utils/replays/highlightNode';\nimport useRAF from 'sentry/utils/replays/hooks/useRAF';\nimport type ReplayReader from 'sentry/utils/replays/replayReader';\nimport usePrevious from 'sentry/utils/usePrevious';\n\ntype Dimensions = {height: number; width: number};\ntype RootElem = null | HTMLDivElement;\n\ntype HighlightParams = {\n  nodeId: number;\n  annotation?: string;\n};\n\n// Important: Don't allow context Consumers to access `Replayer` directly.\n// It has state that, when changed, will not trigger a react render.\n// Instead only expose methods that wrap `Replayer` and manage state.\ntype ReplayPlayerContextProps = {\n  /**\n   * Clear all existing highlights in replay\n   */\n  clearAllHighlights: () => void;\n\n  /**\n   * The time, in milliseconds, where the user focus is.\n   * The user focus can be reported by any collaborating object, usually on\n   * hover.\n   */\n  currentHoverTime: undefined | number;\n\n  /**\n   * The current time of the video, in milliseconds\n   * The value is updated on every animation frame, about every 16.6ms\n   */\n  currentTime: number;\n\n  /**\n   * Original dimensions in pixels of the captured browser window\n   */\n  dimensions: Dimensions;\n\n  /**\n   * The calculated speed of the player when fast-forwarding through idle moments in the video\n   * The value is set to `0` when the video is not fast-forwarding\n   * The speed is automatically determined by the length of each idle period\n   */\n  fastForwardSpeed: number;\n\n  /**\n   * Highlight a node in the replay\n   */\n  highlight: (args: HighlightParams) => void;\n\n  /**\n   * Required to be called with a <div> Ref\n   * Represents the location in the DOM where the iframe video should be mounted\n   *\n   * @param _root\n   */\n  initRoot: (root: RootElem) => void;\n\n  /**\n   * Set to true while the library is reconstructing the DOM\n   */\n  isBuffering: boolean;\n\n  /**\n   * Set to true when the replay finish event is fired\n   */\n  isFinished: boolean;\n\n  /**\n   * Whether the video is currently playing\n   */\n  isPlaying: boolean;\n\n  /**\n   * Whether fast-forward mode is enabled if RRWeb detects idle moments in the video\n   */\n  isSkippingInactive: boolean;\n\n  /**\n   * Removes a highlighted node from the replay\n   */\n  removeHighlight: ({nodeId}: {nodeId: number}) => void;\n\n  /**\n   * The core replay data\n   */\n  replay: ReplayReader | null;\n\n  /**\n   * Restart the replay\n   */\n  restart: () => void;\n\n  /**\n   * Set the currentHoverTime so collaborating components can highlight related\n   * information\n   */\n  setCurrentHoverTime: (time: undefined | number) => void;\n\n  /**\n   * Jump the video to a specific time\n   */\n  setCurrentTime: (time: number) => void;\n\n  /**\n   * Set speed for normal playback\n   */\n  setSpeed: (speed: number) => void;\n\n  /**\n   * The speed for normal playback\n   */\n  speed: number;\n\n  /**\n   * Start or stop playback\n   *\n   * @param play\n   */\n  togglePlayPause: (play: boolean) => void;\n\n  /**\n   * Allow RRWeb to use Fast-Forward mode for idle moments in the video\n   *\n   * @param skip\n   */\n  toggleSkipInactive: (skip: boolean) => void;\n};\n\nconst ReplayPlayerContext = React.createContext<ReplayPlayerContextProps>({\n  clearAllHighlights: () => {},\n  currentHoverTime: undefined,\n  currentTime: 0,\n  dimensions: {height: 0, width: 0},\n  fastForwardSpeed: 0,\n  highlight: () => {},\n  initRoot: () => {},\n  isBuffering: false,\n  isFinished: false,\n  isPlaying: false,\n  isSkippingInactive: true,\n  removeHighlight: () => {},\n  replay: null,\n  restart: () => {},\n  setCurrentHoverTime: () => {},\n  setCurrentTime: () => {},\n  setSpeed: () => {},\n  speed: 1,\n  togglePlayPause: () => {},\n  toggleSkipInactive: () => {},\n});\n\ntype Props = {\n  children: React.ReactNode;\n  replay: ReplayReader | null;\n\n  /**\n   * Time, in seconds, when the video should start\n   */\n  initialTimeOffset?: number;\n\n  /**\n   * Override return fields for testing\n   */\n  value?: Partial<ReplayPlayerContextProps>;\n};\n\nfunction useCurrentTime(callback: () => number) {\n  const [currentTime, setCurrentTime] = useState(0);\n  useRAF(() => setCurrentTime(callback));\n  return currentTime;\n}\n\nexport function Provider({children, replay, initialTimeOffset = 0, value = {}}: Props) {\n  const events = replay?.getRRWebEvents();\n\n  const theme = useTheme();\n  const oldEvents = usePrevious(events);\n  // Note we have to check this outside of hooks, see `usePrevious` comments\n  const hasNewEvents = events !== oldEvents;\n  const replayerRef = useRef<Replayer>(null);\n  const [dimensions, setDimensions] = useState<Dimensions>({height: 0, width: 0});\n  const [currentHoverTime, setCurrentHoverTime] = useState<undefined | number>();\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [finishedAtMS, setFinishedAtMS] = useState<number>(-1);\n  const [isSkippingInactive, setIsSkippingInactive] = useState(true);\n  const [speed, setSpeedState] = useState(1);\n  const [fastForwardSpeed, setFFSpeed] = useState(0);\n  const [buffer, setBufferTime] = useState({target: -1, previous: -1});\n  const playTimer = useRef<number | undefined>(undefined);\n  const unMountedRef = useRef(false);\n\n  const isFinished = replayerRef.current?.getCurrentTime() === finishedAtMS;\n\n  const forceDimensions = (dimension: Dimensions) => {\n    setDimensions(dimension);\n  };\n  const onFastForwardStart = (e: {speed: number}) => {\n    setFFSpeed(e.speed);\n  };\n  const onFastForwardEnd = () => {\n    setFFSpeed(0);\n  };\n\n  const highlight = useCallback(({nodeId, annotation}: HighlightParams) => {\n    const replayer = replayerRef.current;\n    if (!replayer) {\n      return;\n    }\n\n    highlightNode({replayer, nodeId, annotation});\n  }, []);\n\n  const clearAllHighlightsCallback = useCallback(() => {\n    const replayer = replayerRef.current;\n    if (!replayer) {\n      return;\n    }\n\n    clearAllHighlights({replayer});\n  }, []);\n\n  const removeHighlight = useCallback(({nodeId}: {nodeId: number}) => {\n    const replayer = replayerRef.current;\n    if (!replayer) {\n      return;\n    }\n\n    removeHighlightedNode({replayer, nodeId});\n  }, []);\n\n  const setReplayFinished = useCallback(() => {\n    setFinishedAtMS(replayerRef.current?.getCurrentTime() ?? -1);\n    setIsPlaying(false);\n  }, []);\n\n  const initRoot = useCallback(\n    (root: RootElem) => {\n      if (events === undefined) {\n        return;\n      }\n\n      if (root === null) {\n        return;\n      }\n\n      if (replayerRef.current) {\n        if (!hasNewEvents && !unMountedRef.current) {\n          // Already have a player for these events, the parent node must've re-rendered\n          return;\n        }\n\n        if (replayerRef.current.iframe.contentDocument?.body.childElementCount === 0) {\n          // If this is true, then no need to clear old iframe as nothing was rendered\n          return;\n        }\n\n        // We have new events, need to clear out the old iframe because a new\n        // `Replayer` instance is about to be created\n        while (root.firstChild) {\n          root.removeChild(root.firstChild);\n        }\n      }\n\n      // eslint-disable-next-line no-new\n      const inst = new Replayer(events, {\n        root,\n        blockClass: 'sr-block',\n        // liveMode: false,\n        // triggerFocus: false,\n        mouseTail: {\n          duration: 0.75 * 1000,\n          lineCap: 'round',\n          lineWidth: 2,\n          strokeStyle: theme.purple200,\n        },\n        // unpackFn: _ => _,\n        // plugins: [],\n        skipInactive: true,\n      });\n\n      // @ts-expect-error: rrweb types event handlers with `unknown` parameters\n      inst.on(ReplayerEvents.Resize, forceDimensions);\n      inst.on(ReplayerEvents.Finish, setReplayFinished);\n      // @ts-expect-error: rrweb types event handlers with `unknown` parameters\n      inst.on(ReplayerEvents.SkipStart, onFastForwardStart);\n      inst.on(ReplayerEvents.SkipEnd, onFastForwardEnd);\n\n      // `.current` is marked as readonly, but it's safe to set the value from\n      // inside a `useEffect` hook.\n      // See: https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables\n      // @ts-expect-error\n      replayerRef.current = inst;\n\n      if (unMountedRef.current) {\n        unMountedRef.current = false;\n      }\n    },\n    [events, theme.purple200, setReplayFinished, hasNewEvents]\n  );\n\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState !== 'visible') {\n        replayerRef.current?.pause();\n      }\n    };\n\n    if (replayerRef.current && events) {\n      initRoot(replayerRef.current.wrapper.parentElement as RootElem);\n      document.addEventListener('visibilitychange', handleVisibilityChange);\n    }\n\n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [initRoot, events]);\n\n  const getCurrentTime = useCallback(\n    () => (replayerRef.current ? Math.max(replayerRef.current.getCurrentTime(), 0) : 0),\n    []\n  );\n\n  const setCurrentTime = useCallback(\n    (requestedTimeMs: number) => {\n      const replayer = replayerRef.current;\n      if (!replayer) {\n        return;\n      }\n\n      const maxTimeMs = replayerRef.current?.getMetaData().totalTime;\n      const time = requestedTimeMs > maxTimeMs ? 0 : requestedTimeMs;\n\n      // Sometimes rrweb doesn't get to the exact target time, as long as it has\n      // changed away from the previous time then we can hide then buffering message.\n      setBufferTime({target: time, previous: getCurrentTime()});\n\n      // Clear previous timers. Without this (but with the setTimeout) multiple\n      // requests to set the currentTime could finish out of order and cause jumping.\n      if (playTimer.current) {\n        window.clearTimeout(playTimer.current);\n      }\n\n      if (isPlaying) {\n        playTimer.current = window.setTimeout(() => replayer.play(time), 0);\n        setIsPlaying(true);\n      } else {\n        playTimer.current = window.setTimeout(() => replayer.pause(time), 0);\n        setIsPlaying(false);\n      }\n    },\n    [getCurrentTime, isPlaying]\n  );\n\n  const setSpeed = useCallback(\n    (newSpeed: number) => {\n      const replayer = replayerRef.current;\n      if (!replayer) {\n        return;\n      }\n      if (isPlaying) {\n        replayer.pause();\n        replayer.setConfig({speed: newSpeed});\n        replayer.play(getCurrentTime());\n      } else {\n        replayer.setConfig({speed: newSpeed});\n      }\n      setSpeedState(newSpeed);\n    },\n    [getCurrentTime, isPlaying]\n  );\n\n  const togglePlayPause = useCallback(\n    (play: boolean) => {\n      const replayer = replayerRef.current;\n      if (!replayer) {\n        return;\n      }\n\n      if (play) {\n        replayer.play(getCurrentTime());\n      } else {\n        replayer.pause(getCurrentTime());\n      }\n      setIsPlaying(play);\n    },\n    [getCurrentTime]\n  );\n\n  const restart = useCallback(() => {\n    if (replayerRef.current) {\n      replayerRef.current.play(0);\n      setIsPlaying(true);\n    }\n  }, []);\n\n  const toggleSkipInactive = useCallback((skip: boolean) => {\n    const replayer = replayerRef.current;\n    if (!replayer) {\n      return;\n    }\n    if (skip !== replayer.config.skipInactive) {\n      replayer.setConfig({skipInactive: skip});\n    }\n    setIsSkippingInactive(skip);\n  }, []);\n\n  // Only on pageload: set the initial playback timestamp\n  useEffect(() => {\n    if (initialTimeOffset && events && replayerRef.current) {\n      setCurrentTime(initialTimeOffset * 1000);\n    }\n\n    return () => {\n      unMountedRef.current = true;\n    };\n  }, [events, replayerRef.current]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const currentPlayerTime = useCurrentTime(getCurrentTime);\n\n  const [isBuffering, currentTime] =\n    buffer.target !== -1 &&\n    buffer.previous === currentPlayerTime &&\n    buffer.target !== buffer.previous\n      ? [true, buffer.target]\n      : [false, currentPlayerTime];\n\n  if (!isBuffering && buffer.target !== -1) {\n    setBufferTime({target: -1, previous: -1});\n  }\n\n  return (\n    <ReplayPlayerContext.Provider\n      value={{\n        clearAllHighlights: clearAllHighlightsCallback,\n        currentHoverTime,\n        currentTime,\n        dimensions,\n        fastForwardSpeed,\n        highlight,\n        initRoot,\n        isBuffering,\n        isFinished,\n        isPlaying,\n        isSkippingInactive,\n        removeHighlight,\n        replay,\n        restart,\n        setCurrentHoverTime,\n        setCurrentTime,\n        setSpeed,\n        speed,\n        togglePlayPause,\n        toggleSkipInactive,\n        ...value,\n      }}\n    >\n      {children}\n    </ReplayPlayerContext.Provider>\n  );\n}\n\nexport const useReplayContext = () => useContext(ReplayPlayerContext);\n","import {useEffect} from 'react';\n\n// TODO: move into app/utils/*\nexport default function useRAF(callback: () => unknown) {\n  useEffect(() => {\n    const timer = window.requestAnimationFrame(callback);\n    return () => window.cancelAnimationFrame(timer);\n  }, [callback]);\n}\n","import padStart from 'lodash/padStart';\n\nimport {Crumb} from 'sentry/types/breadcrumbs';\nimport type {ReplaySpan} from 'sentry/views/replays/types';\n\nfunction padZero(num: number, len = 2): string {\n  const str = String(num);\n  return padStart(str, len, '0');\n}\n\nconst SECOND = 1000;\nconst MINUTE = 60 * SECOND;\nconst HOUR = 60 * MINUTE;\n\n/**\n * @param timestamp The timestamp that is our reference point. Can be anything that `moment` accepts such as `'2022-05-04T19:47:52.915000Z'` or `1651664872.915`\n * @param diffMs Number of milliseconds to adjust the timestamp by, either positive (future) or negative (past)\n * @returns Unix timestamp of the adjusted timestamp, in milliseconds\n */\nexport function relativeTimeInMs(\n  timestamp: ConstructorParameters<typeof Date>[0],\n  diffMs: number\n): number {\n  return Math.abs(new Date(timestamp).getTime() - diffMs);\n}\n\nexport function showPlayerTime(\n  timestamp: ConstructorParameters<typeof Date>[0],\n  relativeTimeMs: number,\n  showMs: boolean = false\n): string {\n  return formatTime(relativeTimeInMs(timestamp, relativeTimeMs), showMs);\n}\n\n// TODO: move into 'sentry/utils/formatters'\nexport function formatTime(ms: number, showMs?: boolean): string {\n  if (ms <= 0 || isNaN(ms)) {\n    if (showMs) {\n      return '00:00.000';\n    }\n\n    return '00:00';\n  }\n\n  const hour = Math.floor(ms / HOUR);\n  ms = ms % HOUR;\n  const minute = Math.floor(ms / MINUTE);\n  ms = ms % MINUTE;\n  const second = Math.floor(ms / SECOND);\n\n  let formattedTime = '00:00';\n\n  if (hour) {\n    formattedTime = `${padZero(hour)}:${padZero(minute)}:${padZero(second)}`;\n  } else {\n    formattedTime = `${padZero(minute)}:${padZero(second)}`;\n  }\n\n  if (showMs) {\n    const milliseconds = Math.floor(ms % SECOND);\n    formattedTime = `${formattedTime}.${padZero(milliseconds, 3)}`;\n  }\n\n  return formattedTime;\n}\n\n/**\n * Figure out how many ticks to show in an area.\n * If there is more space available, we can show more granular ticks, but if\n * less space is available, fewer ticks.\n * Similarly if the duration is short, the ticks will represent a short amount\n * of time (like every second) but if the duration is long one tick may\n * represent an hour.\n *\n * @param durationMs The amount of time that we need to chop up into even sections\n * @param width Total width available, pixels\n * @param minWidth Minimum space for each column, pixels. Ex: So we can show formatted time like `1:00:00` between major ticks\n * @returns\n */\nexport function countColumns(durationMs: number, width: number, minWidth: number = 50) {\n  let maxCols = Math.floor(width / minWidth);\n  const remainder = durationMs - maxCols * width > 0 ? 1 : 0;\n  maxCols -= remainder;\n\n  // List of all the possible time granularities to display\n  // We could generate the list, which is basically a version of fizzbuzz, hard-coding is quicker.\n  const timeOptions = [\n    1 * HOUR,\n    30 * MINUTE,\n    20 * MINUTE,\n    15 * MINUTE,\n    10 * MINUTE,\n    5 * MINUTE,\n    2 * MINUTE,\n    1 * MINUTE,\n    30 * SECOND,\n    10 * SECOND,\n    5 * SECOND,\n    1 * SECOND,\n  ];\n\n  const timeBasedCols = timeOptions.reduce<Map<number, number>>((map, time) => {\n    map.set(time, Math.floor(durationMs / time));\n    return map;\n  }, new Map());\n\n  const [timespan, cols] = Array.from(timeBasedCols.entries())\n    .filter(([_span, c]) => c <= maxCols) // Filter for any valid timespan option where all ticks would fit\n    .reduce((best, next) => (next[1] > best[1] ? next : best), [0, 0]); // select the timespan option with the most ticks\n\n  const remaining = (durationMs - timespan * cols) / timespan;\n  return {timespan, cols, remaining};\n}\n\n/**\n * Group Crumbs for display along the timeline.\n *\n * The timeline is broken down into columns (aka buckets, or time-slices).\n * Columns translate to a fixed width on the screen, to prevent side-scrolling.\n *\n * This function groups crumbs into columns based on the number of columns available\n * and the timestamp of the crumb.\n */\nexport function getCrumbsByColumn(\n  startTimestampMs: number,\n  durationMs: number,\n  crumbs: Crumb[],\n  totalColumns: number\n) {\n  const safeDurationMs = isNaN(durationMs) ? 1 : durationMs;\n\n  const columnCrumbPairs = crumbs.map(breadcrumb => {\n    const {timestamp} = breadcrumb;\n    const timestampMilliSeconds = +new Date(String(timestamp));\n    const sinceStart = isNaN(timestampMilliSeconds)\n      ? 0\n      : timestampMilliSeconds - startTimestampMs;\n\n    const columnPositionCalc =\n      Math.floor((sinceStart / safeDurationMs) * (totalColumns - 1)) + 1;\n\n    // Should start at minimum in the first column\n    const column = Math.max(1, columnPositionCalc);\n\n    return [column, breadcrumb] as [number, Crumb];\n  });\n\n  const crumbsByColumn = columnCrumbPairs.reduce((map, [column, breadcrumb]) => {\n    if (map.has(column)) {\n      map.get(column)?.push(breadcrumb);\n    } else {\n      map.set(column, [breadcrumb]);\n    }\n    return map;\n  }, new Map() as Map<number, Crumb[]>);\n\n  return crumbsByColumn;\n}\n\ntype FlattenedSpanRange = {\n  /**\n   * Duration of this range\n   */\n  duration: number;\n  /**\n   * Absolute time in ms when the range ends\n   */\n  endTimestamp: number;\n  /**\n   * Number of spans that got flattened into this range\n   */\n  spanCount: number;\n  /**\n   * ID of the original span that created this range\n   */\n  spanId: string;\n  //\n  /**\n   * Absolute time in ms when the span starts\n   */\n  startTimestamp: number;\n};\n\nfunction doesOverlap(a: FlattenedSpanRange, b: FlattenedSpanRange) {\n  const bStartsWithinA =\n    a.startTimestamp <= b.startTimestamp && b.startTimestamp <= a.endTimestamp;\n  const bEndsWithinA =\n    a.startTimestamp <= b.endTimestamp && b.endTimestamp <= a.endTimestamp;\n  return bStartsWithinA || bEndsWithinA;\n}\n\nexport function flattenSpans(rawSpans: ReplaySpan[]): FlattenedSpanRange[] {\n  if (!rawSpans.length) {\n    return [];\n  }\n\n  const spans = rawSpans.map(span => {\n    const startTimestamp = span.startTimestamp * 1000;\n\n    // `endTimestamp` is at least msPerPixel wide, otherwise it disappears\n    const endTimestamp = span.endTimestamp * 1000;\n    return {\n      spanCount: 1,\n      // spanId: span.span_id,\n      startTimestamp,\n      endTimestamp,\n      duration: endTimestamp - startTimestamp,\n    } as FlattenedSpanRange;\n  });\n\n  const [firstSpan, ...restSpans] = spans;\n  const flatSpans = [firstSpan];\n\n  for (const span of restSpans) {\n    let overlap = false;\n    for (const fspan of flatSpans) {\n      if (doesOverlap(fspan, span)) {\n        overlap = true;\n        fspan.spanCount += 1;\n        fspan.startTimestamp = Math.min(fspan.startTimestamp, span.startTimestamp);\n        fspan.endTimestamp = Math.max(fspan.endTimestamp, span.endTimestamp);\n        fspan.duration = fspan.endTimestamp - fspan.startTimestamp;\n        break;\n      }\n    }\n    if (!overlap) {\n      flatSpans.push(span);\n    }\n  }\n  return flatSpans;\n}\n\n/**\n * Divide two numbers safely\n */\nexport function divide(numerator: number, denominator: number | undefined) {\n  if (denominator === undefined || isNaN(denominator) || denominator === 0) {\n    return 0;\n  }\n  return numerator / denominator;\n}\n","import {useEffect, useState} from 'react';\nimport {Location} from 'history';\n\nimport {NewQuery} from 'sentry/types';\nimport EventView from 'sentry/utils/discover/eventView';\nimport useApi from 'sentry/utils/useApi';\nimport useOrganization from 'sentry/utils/useOrganization';\n\ntype OptionalProperties = 'projects' | 'environment' | 'id' | 'name' | 'version';\ninterface Params {\n  /**\n   * The Discover query to perform. This is a function because we will require the consumer of the hook to memoize this function.\n   */\n  discoverQuery: Omit<NewQuery, OptionalProperties> &\n    Partial<Pick<NewQuery, OptionalProperties>>;\n\n  endpoint?: string;\n\n  /**\n   * Should we ignore the current URL parameter `cursor`?\n   *\n   * This is useful when we are making nested discover queries and the child queries have their own cursor (or do not need it at all).\n   */\n  ignoreCursor?: boolean;\n}\n\ninterface State<T> {\n  data: T[] | undefined;\n  error: Error | undefined;\n  isLoading: boolean;\n  pageLinks: string | undefined;\n}\n\nconst INITIAL_STATE: Readonly<State<any>> = {\n  isLoading: true,\n  error: undefined,\n  data: undefined,\n  pageLinks: undefined,\n};\n\nconst FAKE_LOCATION = {\n  query: {},\n} as Location;\n\n/**\n * Simple custom hook to perform a Discover query.\n *\n * Note this does *not* handle URL parameters like the render component `<DiscoverQuery>`.\n * It will need to be handled in a parent.\n */\nexport default function useDiscoverQuery<T = unknown>({\n  endpoint,\n  discoverQuery,\n  ignoreCursor,\n}: Params) {\n  const [state, setState] = useState<State<T>>(INITIAL_STATE);\n  const api = useApi();\n  const organization = useOrganization();\n\n  useEffect(() => {\n    async function runQuery() {\n      const url = endpoint || `/organizations/${organization.slug}/eventsv2/`;\n      const eventView = EventView.fromNewQueryWithLocation(\n        {\n          environment: [],\n          projects: [],\n          id: '',\n          name: '',\n          version: 2,\n          ...discoverQuery,\n        },\n        FAKE_LOCATION\n      );\n      const query = eventView.getEventsAPIPayload(FAKE_LOCATION);\n\n      setState(prevState => ({...prevState, isLoading: true, error: undefined}));\n      api.clear();\n\n      try {\n        const [data, , resp] = await api.requestPromise(url, {\n          includeAllArgs: true,\n          query,\n        });\n        setState(prevState => ({\n          ...prevState,\n          isLoading: false,\n          error: undefined,\n          pageLinks: resp?.getResponseHeader('Link') ?? prevState.pageLinks,\n          data: data.data,\n        }));\n      } catch (error) {\n        setState(prevState => ({\n          ...prevState,\n          isLoading: false,\n          error,\n          data: undefined,\n        }));\n      }\n    }\n\n    runQuery();\n\n    // location is ignored in deps array, see getEventView comments\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [endpoint, discoverQuery, organization.slug, ignoreCursor]);\n\n  return state;\n}\n"],"names":["ReplayContent","eventSlug","orgId","fetching","replay","fetchError","useReplayData","ref","fullscreenRef","toggle","toggleFullscreen","useFullscreen","replayRecord","getReplay","replayEvent","getEvent","Error","className","t","initialTimeOffset","PlayerContainer","showAddressBar","replayId","culprit","year","seconds","utc","date","startedAt","duration","fixedDigits","StyledPlaceholder","height","width","FluidHeight","space","p","theme","background","Placeholder","highlightsByNodeId","Map","removeHighlightedNode","replayer","nodeId","has","highlightObj","get","wrapper","contains","canvas","removeChild","delete","ReplayPlayerContext","React","clearAllHighlights","currentHoverTime","undefined","currentTime","dimensions","fastForwardSpeed","highlight","initRoot","isBuffering","isFinished","isPlaying","isSkippingInactive","removeHighlight","restart","setCurrentHoverTime","setCurrentTime","setSpeed","speed","togglePlayPause","toggleSkipInactive","Provider","children","value","events","getRRWebEvents","useTheme","oldEvents","usePrevious","hasNewEvents","replayerRef","useRef","setDimensions","useState","setIsPlaying","finishedAtMS","setFinishedAtMS","setIsSkippingInactive","setSpeedState","setFFSpeed","buffer","setBufferTime","target","previous","playTimer","unMountedRef","current","getCurrentTime","forceDimensions","dimension","onFastForwardStart","e","onFastForwardEnd","useCallback","annotation","color","mouseTail","node","getMirror","getNode","iframe","contentDocument","body","top","left","getBoundingClientRect","highlightColor","cloneNode","ctx","getContext","fillStyle","fillRect","beginPath","setLineDash","moveTo","lineTo","closePath","stroke","font","textAlign","textBaseline","textWidth","measureText","fillText","set","insertBefore","highlightNode","clearAllHighlightsCallback","keys","setReplayFinished","root","childElementCount","firstChild","inst","Replayer","blockClass","lineCap","lineWidth","strokeStyle","purple200","skipInactive","on","ReplayerEvents","useEffect","handleVisibilityChange","document","visibilityState","pause","parentElement","addEventListener","removeEventListener","Math","max","requestedTimeMs","time","getMetaData","totalTime","window","clearTimeout","setTimeout","play","newSpeed","setConfig","skip","config","currentPlayerTime","callback","timer","requestAnimationFrame","cancelAnimationFrame","useRAF","useCurrentTime","useReplayContext","useContext","padZero","num","len","str","String","padStart","HOUR","relativeTimeInMs","timestamp","diffMs","abs","Date","getTime","showPlayerTime","relativeTimeMs","showMs","formatTime","ms","isNaN","hour","floor","minute","second","formattedTime","countColumns","durationMs","minWidth","maxCols","remainder","timeOptions","timeBasedCols","reduce","map","timespan","cols","Array","from","entries","filter","_span","c","best","next","remaining","getCrumbsByColumn","startTimestampMs","crumbs","totalColumns","safeDurationMs","breadcrumb","timestampMilliSeconds","sinceStart","columnPositionCalc","column","push","doesOverlap","a","b","bStartsWithinA","startTimestamp","endTimestamp","bEndsWithinA","flattenSpans","rawSpans","length","spans","span","spanCount","firstSpan","restSpans","flatSpans","overlap","fspan","min","divide","numerator","denominator","INITIAL_STATE","isLoading","error","data","pageLinks","FAKE_LOCATION","query","useDiscoverQuery","endpoint","discoverQuery","ignoreCursor","state","setState","api","useApi","organization","useOrganization","async","url","slug","EventView","environment","projects","id","name","version","getEventsAPIPayload","prevState","clear","resp","requestPromise","includeAllArgs","getResponseHeader","runQuery"],"sourceRoot":""}