"""This module is for the translation mapping data of the
following document:

Document file: notes_of_handler_scope_assignment.md
Language: jp
"""

from typing import Dict

MAPPING: Dict[str, str] = {
    ##################################################
    "# Notes of the variable assignment in a handler scope": "# ハンドラスコープ内での変数割り当てに関する特記事項",  # noqa
    ##################################################
    "This page explains the notes of the variable assignment in a handler scope.": "このページでのハンドラスコープ内での変数割り当てに関する各特記事項について説明します。",  # noqa
    ##################################################
    "## Current restriction of the variable assignment": "## 変数割り当ての現在の制限",
    ##################################################
    "Currently, the apysc library does not support basic types\' (e.g., `ap.Int`, `ap.String`, and `ap.Boolean`) variable assignment (instantiation) in a handler scope.": "現在apyscライブラリではハンドラのスコープ内での基本的な型（例 : `ap.Int`や`ap.String`、`ap.Boolean`など）の値の変数割り当て（インスタンス化）をサポートしていません。",  # noqa
    ##################################################
    "For example, the code of `x: ap.Int = ap.Int(50)` in the handler raises an exception, as follows:": "例えば以下のように、ハンドラスコープ内での`x: ap.Int = ap.Int(50)`といったようなコードは例外を発生させます:",  # noqa
    ##################################################
    "```py\nimport apysc as ap\n\n\ndef on_timer(e: ap.TimerEvent, options: dict) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : dict\n        Optional arguments dictionary.\n    \"\"\"\n    x: ap.Int = ap.Int(50)\n    ap.trace(\"x:\", x)\n\n\nap.Timer(handler=on_timer, delay=1000, repeat_count=1).start()\n```": "```py\nimport apysc as ap\n\n\ndef on_timer(e: ap.TimerEvent, options: dict) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : dict\n        Optional arguments dictionary.\n    \"\"\"\n    x: ap.Int = ap.Int(50)\n    ap.trace(\"x:\", x)\n\n\nap.Timer(handler=on_timer, delay=1000, repeat_count=1).start()\n```",  # noqa
    ##################################################
    "```\n...\napysc._validation.handler_validation.InvalidAssignmentInHandler: Assigning values of basic types such as the ap.Int or ap.String to variables is not supported in a handler.\n\nInstead, consider passing a predefined value to a second argument dictionary of a handler, or updating it via the `value` property.\n\nE.g.,\nx = options[\"x\"]\nx.value = ap.Int(...)\n...\n```": "```\n...\napysc._validation.handler_validation.InvalidAssignmentInHandler: Assigning values of basic types such as the ap.Int or ap.String to variables is not supported in a handler.\n\nInstead, consider passing a predefined value to a second argument dictionary of a handler, or updating it via the `value` property.\n\nE.g.,\nx = options[\"x\"]\nx.value = ap.Int(...)\n...\n```",  # noqa
    ##################################################
    "If you want to use a variable assignment in a handler scope, please create it outside the handler scope and pass it through the `options` argument, for example:": "ハンドラのスコープ内で変数割り当てなどの制御を行いたい場合には以下のようにハンドラのスコープ外でその変数を作成し、その値をハンドラの`options`引数へ渡す対応等を検討してください:",  # noqa
    ##################################################
    "```py\n# runnable\nimport apysc as ap\n\nfrom typing_extensions import TypedDict\n\n\nclass XOptions(TypedDict):\n    x: ap.Int\n\n\ndef on_timer(e: ap.TimerEvent, options: XOptions) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : XOptions\n        Optional arguments dictionary.\n    \"\"\"\n    ap.trace(\"x:\", options[\"x\"])\n\n\noptions: XOptions = {\"x\": ap.Int(50)}\nap.Timer(handler=on_timer, delay=1000, repeat_count=1, options=options).start()\n```": "```py\n# runnable\nimport apysc as ap\n\nfrom typing_extensions import TypedDict\n\n\nclass XOptions(TypedDict):\n    x: ap.Int\n\n\ndef on_timer(e: ap.TimerEvent, options: XOptions) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : XOptions\n        Optional arguments dictionary.\n    \"\"\"\n    ap.trace(\"x:\", options[\"x\"])\n\n\noptions: XOptions = {\"x\": ap.Int(50)}\nap.Timer(handler=on_timer, delay=1000, repeat_count=1, options=options).start()\n```",  # noqa
    ##################################################
    "It applies this restriction only when it instantiates and assigns a new variable.": "この制限はインスタンス化と変数割り当てが同時に実行される場合のみ対象となります。",  # noqa
    ##################################################
    "So if an assignment does not instantiate a variable, it does not raise an exception, as follows (`x: ap.Int = options[\"x\"]`):": "そのため以下のコード（`x: ap.Int = options[\"x\"]`）のような変数のインスタンス化を伴わない変数の割り当てなどは例外を発生させません:",  # noqa
    ##################################################
    "```py\n# runnable\nimport apysc as ap\n\nfrom typing_extensions import TypedDict\n\n\nclass XOptions(TypedDict):\n    x: ap.Int\n\n\ndef on_timer(e: ap.TimerEvent, options: XOptions) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : XOptions\n        Optional arguments dictionary.\n    \"\"\"\n    x: ap.Int = options[\"x\"]\n    ap.trace(\"x:\", x)\n\n\noptions: XOptions = {\"x\": ap.Int(50)}\nap.Timer(handler=on_timer, delay=1000, repeat_count=1, options=options).start()\n```": "```py\n# runnable\nimport apysc as ap\n\nfrom typing_extensions import TypedDict\n\n\nclass XOptions(TypedDict):\n    x: ap.Int\n\n\ndef on_timer(e: ap.TimerEvent, options: XOptions) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : XOptions\n        Optional arguments dictionary.\n    \"\"\"\n    x: ap.Int = options[\"x\"]\n    ap.trace(\"x:\", x)\n\n\noptions: XOptions = {\"x\": ap.Int(50)}\nap.Timer(handler=on_timer, delay=1000, repeat_count=1, options=options).start()\n```",  # noqa
    ##################################################
    "Not an apysc basic types (such as the Python built-in types) also do not raise an exception (e.g., `x: int = 50`):": "Pythonのビルトインの型など、apyscの基本的な値の型以外でも同様に例外を発生させません（例 : `x: int = 50`）:",  # noqa
    ##################################################
    "```py\n# runnable\nimport apysc as ap\n\n\ndef on_timer(e: ap.TimerEvent, options: dict) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : dict\n        Optional arguments dictionary.\n    \"\"\"\n    x: int = 50\n    ap.trace(\"x:\", x)\n\n\nap.Timer(handler=on_timer, delay=1000, repeat_count=1).start()\n```": "```py\n# runnable\nimport apysc as ap\n\n\ndef on_timer(e: ap.TimerEvent, options: dict) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : dict\n        Optional arguments dictionary.\n    \"\"\"\n    x: int = 50\n    ap.trace(\"x:\", x)\n\n\nap.Timer(handler=on_timer, delay=1000, repeat_count=1).start()\n```",  # noqa
    ##################################################
    "A value\'s updating (e.g., `x.value = ap.Int(100)`) in a handler scope is also acceptable:": "ハンドラのスコープ内での変数の値の更新（例 : `x.value = ap.Int(100)`）も同様にエラーを発生させずに使用することができます:",  # noqa
    ##################################################
    "```py\n# runnable\nimport apysc as ap\n\nfrom typing_extensions import TypedDict\n\n\nclass XOptions(TypedDict):\n    x: ap.Int\n\n\ndef on_timer(e: ap.TimerEvent, options: XOptions) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : XOptions\n        Optional arguments dictionary.\n    \"\"\"\n    x: ap.Int = options[\"x\"]\n    x.value = ap.Int(100)\n    ap.trace(\"x:\", x)\n\n\noptions: XOptions = {\"x\": ap.Int(50)}\nap.Timer(handler=on_timer, delay=1000, repeat_count=1, options=options).start()\n```": "```py\n# runnable\nimport apysc as ap\n\nfrom typing_extensions import TypedDict\n\n\nclass XOptions(TypedDict):\n    x: ap.Int\n\n\ndef on_timer(e: ap.TimerEvent, options: XOptions) -> None:\n    \"\"\"\n    The timer event handler.\n\n    Parameters\n    ----------\n    e : ap.TimerEvent\n        Event instance.\n    options : XOptions\n        Optional arguments dictionary.\n    \"\"\"\n    x: ap.Int = options[\"x\"]\n    x.value = ap.Int(100)\n    ap.trace(\"x:\", x)\n\n\noptions: XOptions = {\"x\": ap.Int(50)}\nap.Timer(handler=on_timer, delay=1000, repeat_count=1, options=options).start()\n```",  # noqa
}
