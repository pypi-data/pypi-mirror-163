# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_network.ipynb.

# %% auto 0
__all__ = ['Trace']

# %% ../00_network.ipynb 2
from fastcore.utils import *
import networkx as nx
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from numpy.linalg import inv
from numpy.linalg import matrix_power

# %% ../00_network.ipynb 11
class Trace():
    '''
    Calcuate the electrical flows in a network based on the paper: 
    Electricity Tracing in Systems With and Without Circulating Flows: Physical Insights and Mathematical Proofs 
    DOI: 10.1109/TPWRS.2009.2037506
    '''
    def __init__(self, 
                atol=20, # absolute tolerance
                rtol =.05 # relative tolerance 
                ):
        self.atol = atol 
        self.rtol = rtol 

# %% ../00_network.ipynb 13
@patch
def _network(self:Trace, 
            bus, # bus dataframe
            branch # branch dataframe
            ):
    self.network = nx.from_pandas_edgelist(branch,
                                source='FROM_STATION',
                                target='TO_STATION',
                                edge_attr=True,
                                create_using=nx.DiGraph())

    # ADD DEMAND AND GENERATION AT EACH NODE
    for x in self.network.nodes:
        self.network.nodes[x]['GENERATION_MW'] = bus[bus.ID_ST == x].GENERATION.sum() 
        self.network.nodes[x]['DEMAND_MW'] = bus[bus.ID_ST == x].LOAD.sum() 

# %% ../00_network.ipynb 16
@patch
def plot_model(self:Trace):
    pos = {'I':(0,0),
           'II':(.5,0),
           'III':(1,0),
           'IV':(1,-.5),
           'V':(1.5,0),
           'VI':(1.5,.5)}
    fig = plt.figure(1, figsize=(20, 10), dpi=60)
    
    options = {
        "font_size": 20,
        "font_color":'black',
        "node_size": 5000,
        "node_color": 'white',
        "edge_cmap": "cm.magma",
        "edgecolors": 'black',
        "arrowstyle":"->",
        "arrowsize":20,
        "width":5,
        }

    tmp = nx.draw_networkx(self.network, pos, **options)
    for x in self.network.nodes:
        #GENERATION
        if self.network.nodes[x]['GENERATION_MW'] > 0:
            plt.annotate(f'{round(self.network.nodes[x]["GENERATION_MW"],1)} MW', 
                            xy=(pos[x][0]-.06*np.sin(np.pi/4),
                                pos[x][1]-.06*np.cos(np.pi/4)), 
                            xytext=(pos[x][0]-.2*np.sin(np.pi/4),
                                    pos[x][1]-.2*np.cos(np.pi/4)),
                                color='black',
                                fontsize=12,
                            arrowprops=dict(arrowstyle="->", 
                                            lw=4, 
                                            color="g"))

        #DEMAND
        if self.network.nodes[x]['DEMAND_MW'] > 0:
            plt.annotate(f'{round(self.network.nodes[x]["DEMAND_MW"],1)} MW', 
                        xy=(pos[x][0]+.06*np.sin(np.pi/4),
                            pos[x][1]-.06*np.cos(np.pi/4)), 
                        xytext=(pos[x][0]+.2*np.sin(np.pi/4)-.05,
                                pos[x][1]-.2*np.cos(np.pi/4)),
                        color='r',fontsize=12,
                        arrowprops=dict(arrowstyle="<-", 
                    lw=4, color="red"))

    edge_labels = {}
    for x in self.network.edges:
        tmp = self.network.edges[x]
        edge_labels[x] = f'{str(tmp["FROM_MW"])} MW ' if tmp["FROM_MW"]==tmp["TO_MW"] else f'{str(round(tmp["FROM_MW"],1))} MW / {str(round(tmp["TO_MW"],1))} MW '

    nx.draw_networkx_edge_labels(
            self.network, pos,
            edge_labels=edge_labels,
            font_color='black',
            font_size =10
        )
    plt.axis("off")
    return plt

# %% ../00_network.ipynb 19
@patch
def _power(self:Trace):
    #total flow entering node
    self.P_IN = np.array([np.sum([self.network._adj[y][x]['TO_MW'] for y in list(self.network.predecessors(x))]) + # sum of flow entering node
                          self.network.nodes[x]['GENERATION_MW'] for x in self.network.nodes]) # Generation at the node

    # can have negative generation from say a battery charging - want to highlight this but clip to 0 to keep matrix solver happy
    if self.P_IN.min()<=-10:
        print(f'P_IN is lower than -10 :  -{self.P_IN.min()}')
    self.P_IN = self.P_IN.clip(min=.01) # clip to 0.01 to avoid numerical issues

        
    #SUM OF FLOWS LEAVING NODES
    self.P_OUT = np.array([np.sum([self.network[y][x]['FROM_MW'] for x in self.network[y]])+
                            self.network.nodes[y]['DEMAND_MW'] for y in self.network.nodes])
    if self.P_OUT.min() < 0: # should be zero or positive
        print(f'P_OUT is lower than 0 :  -{self.P_IN.min()}')
    self.P = self.P_IN

    #SUM OF GENERATION NODES
    self.P_G = np.array([self.network.nodes[x]['GENERATION_MW'] for x in self.network.nodes])
                            
    # SUM OF DEMAND AT NODES
    self.P_D =  np.array([self.network.nodes[x]['DEMAND_MW'] for x in self.network.nodes])

    self.F_recieve = np.array([self.network._adj[x[0]][x[1]]['TO_MW'] for x in self.network.edges])
    self.F_send = np.array([self.network._adj[x[0]][x[1]]['FROM_MW'] for x in self.network.edges])
    return

# %% ../00_network.ipynb 23
@patch
def _matrix(self:Trace):
    self.m =len(self.F_recieve)
    self.nbus = len(self.P)

    #SET UP THE NODE ID DICTIONARY
    self.node_id = {x:i for i, x in enumerate(self.network.nodes)}
    self.id_node = {i:x for i, x in enumerate(self.network.nodes)}
    ## incidence matrix B (1)    
    self.B = np.zeros([self.m, self.nbus])
    for n,x in enumerate(self.network.edges):
        self.B[n,self.node_id[x[0]]] = 1
        self.B[n,self.node_id[x[1]]] = -1

    self.B_u = np.where(self.B<0,-1,0)
    self.B_d = np.where(self.B>0,1,0)
        
    #adjacency matrix [no_buses x no_buses]
    self.C = -self.B_d.T@self.B_u

    diag_f_recieve = np.eye(self.m)*self.F_recieve
    diag_f_send = np.eye(self.m)*self.F_send
        
#         self.Fd = -self.B_d.T @ diag_f @ self.B_u
    self.Fd_recieve = -self.B_d.T @ diag_f_recieve @ self.B_u
    self.Fd_send = -self.B_d.T @ diag_f_send @ self.B_u
        
    diag_p = np.eye(self.nbus) * self.P
    
    self.A_d = np.eye(self.nbus) + self.B_d.T @ diag_f_recieve @ self.B_u @ inv(diag_p)
    self.A_u = np.eye(self.nbus) + self.B_u.T @ diag_f_send    @ self.B_d @ inv(diag_p)
        
    self.net_matrix =   (np.array([(self.P_G / self.P)]).T * (inv(self.A_d) * self.P_D))
    self.gross_matrix = (np.array([(self.P_D / self.P)]).T * (inv(self.A_u) * self.P_G))

@patch
def _make_df(self:Trace):
    self.df = pd.DataFrame(np.concatenate([self.net_matrix, self.gross_matrix.T], axis=1), 
                    columns = [ x + '_net' for x in self.network.nodes] + [ x +'_gross' for x in self.network.nodes])
    self.df.insert(loc=0, column='GENERATION', value=self.network.nodes)

    # self.df = self.df.loc[self.df.sum(axis=1)!=0,self.df.sum(axis=0)!=0]
    return self.df

# %% ../00_network.ipynb 25
@patch
def process(self:Trace, bus, branch):
    self._network(bus, branch)
    self._power()
    self._matrix()
    self._make_df()

# %% ../00_network.ipynb 26
@patch
def plot_node(self:Trace, node:str):
    fig = plt.figure(1, figsize=(20, 10), dpi=60)
    sub_net_nodes = list(trace.network.predecessors(node))+list(trace.network.successors(node))+[node]
    sub_net = nx.subgraph(self.network, sub_net_nodes)
    options = {
        "font_size": 20,
        "font_color":'black',
        "node_size": 5000,
        "node_color": 'white',
        "edge_cmap": "cm.magma",
        "edgecolors": 'black',
        "arrowstyle":"->",
        "arrowsize":20,
        "width":5,
        }
    pos = {'I':(0,0),
           'II':(.5,0),
           'III':(1,0),
           'IV':(1,-.5),
           'V':(1.5,0),
           'VI':(1.5,.5)}

    tmp = nx.draw_networkx(sub_net, pos=pos, **options)
    for x in sub_net.nodes:
        #GENERATION
        if sub_net.nodes[x]['GENERATION_MW'] > 0:
            plt.annotate(f'{round(sub_net.nodes[x]["GENERATION_MW"],1)} MW', 
                            xy=(pos[x][0]-.06*np.sin(np.pi/4),
                                pos[x][1]-.06*np.cos(np.pi/4)), 
                            xytext=(pos[x][0]-.2*np.sin(np.pi/4),
                                    pos[x][1]-.2*np.cos(np.pi/4)),
                                color='black',
                                fontsize=12,
                            arrowprops=dict(arrowstyle="->", 
                                            lw=4, 
                                            color="g"))

        #DEMAND
        if sub_net.nodes[x]['DEMAND_MW'] > 0:
            plt.annotate(f'{round(sub_net.nodes[x]["DEMAND_MW"],1)} MW', 
                        xy=(pos[x][0]+.06*np.sin(np.pi/4),
                            pos[x][1]-.06*np.cos(np.pi/4)), 
                        xytext=(pos[x][0]+.2*np.sin(np.pi/4)-.05,
                                pos[x][1]-.2*np.cos(np.pi/4)),
                        color='r',fontsize=12,
                        arrowprops=dict(arrowstyle="<-", 
                    lw=4, color="red"))

    edge_labels = {}
    for x in sub_net.edges:
        tmp = trace.network.edges[x]
        edge_labels[x] = f'{str(tmp["FROM_MW"])} MW ' if tmp["FROM_MW"]==tmp["TO_MW"] else f'{str(round(tmp["FROM_MW"],1))} MW / {str(round(tmp["TO_MW"],1))} MW '

    nx.draw_networkx_edge_labels(
            sub_net, pos,
            edge_labels=edge_labels,
            font_color='black',
            font_size =10
        )
    plt.axis("off")
    return plt
