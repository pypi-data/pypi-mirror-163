{"version":3,"file":"d4aaa774.js","mappings":";;;AAoDA;AACA;AACA;AACA;;;;;;;;;;;;AApCA;AC2DA;AAKA;AAGA;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;AAOA;AACA;AACA;AACA;AAGA;;;;;;;;;AApFA;;ACsKA;AAaA;;AAIA;;;AAIA;AACA;;AAEA;;;AAMA;AACA;AACA;AACA;;;AAQA;;AAGA;AAKA;;AAKA;;;;;;;;;AAjNA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA","sources":["webpack://home-assistant-frontend/./src/components/ha-web-rtc-player.ts","webpack://home-assistant-frontend/./src/components/ha-camera-stream.ts","webpack://home-assistant-frontend/./src/panels/lovelace/components/hui-image.ts"],"sourcesContent":["import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state, query } from \"lit/decorators\";\nimport { handleWebRtcOffer, WebRtcAnswer } from \"../data/camera\";\nimport type { HomeAssistant } from \"../types\";\nimport \"./ha-alert\";\n\n/**\n * A WebRTC stream is established by first sending an offer through a signal\n * path via an integration. An answer is returned, then the rest of the stream\n * is handled entirely client side.\n */\n@customElement(\"ha-web-rtc-player\")\nclass HaWebRtcPlayer extends LitElement {\n  @property({ attribute: false }) public hass!: HomeAssistant;\n\n  @property() public entityid!: string;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"autoplay\" })\n  public autoPlay = false;\n\n  @property({ type: Boolean, attribute: \"playsinline\" })\n  public playsInline = false;\n\n  @state() private _error?: string;\n\n  // don't cache this, as we remove it on disconnects\n  @query(\"#remote-stream\") private _videoEl!: HTMLVideoElement;\n\n  private _peerConnection?: RTCPeerConnection;\n\n  private _remoteStream?: MediaStream;\n\n  protected override render(): TemplateResult {\n    if (this._error) {\n      return html`<ha-alert alert-type=\"error\">${this._error}</ha-alert>`;\n    }\n    return html`\n      <video\n        id=\"remote-stream\"\n        ?autoplay=${this.autoPlay}\n        .muted=${this.muted}\n        ?playsinline=${this.playsInline}\n        ?controls=${this.controls}\n      ></video>\n    `;\n  }\n\n  public override connectedCallback() {\n    super.connectedCallback();\n    if (this.hasUpdated) {\n      this._startWebRtc();\n    }\n  }\n\n  public override disconnectedCallback() {\n    super.disconnectedCallback();\n    this._cleanUp();\n  }\n\n  protected override updated(changedProperties: PropertyValues<this>) {\n    if (!changedProperties.has(\"entityid\")) {\n      return;\n    }\n    if (!this._videoEl) {\n      return;\n    }\n    this._startWebRtc();\n  }\n\n  private async _startWebRtc(): Promise<void> {\n    this._error = undefined;\n\n    const peerConnection = new RTCPeerConnection();\n    // Some cameras (such as nest) require a data channel to establish a stream\n    // however, not used by any integrations.\n    peerConnection.createDataChannel(\"dataSendChannel\");\n    peerConnection.addTransceiver(\"audio\", { direction: \"recvonly\" });\n    peerConnection.addTransceiver(\"video\", { direction: \"recvonly\" });\n\n    const offerOptions: RTCOfferOptions = {\n      offerToReceiveAudio: true,\n      offerToReceiveVideo: true,\n    };\n    const offer: RTCSessionDescriptionInit = await peerConnection.createOffer(\n      offerOptions\n    );\n    await peerConnection.setLocalDescription(offer);\n\n    let webRtcAnswer: WebRtcAnswer;\n    try {\n      webRtcAnswer = await handleWebRtcOffer(\n        this.hass,\n        this.entityid,\n        offer.sdp!\n      );\n    } catch (err: any) {\n      this._error = \"Failed to start WebRTC stream: \" + err.message;\n      peerConnection.close();\n      return;\n    }\n\n    // Setup callbacks to render remote stream once media tracks are discovered.\n    const remoteStream = new MediaStream();\n    peerConnection.addEventListener(\"track\", (event) => {\n      remoteStream.addTrack(event.track);\n      this._videoEl.srcObject = remoteStream;\n    });\n    this._remoteStream = remoteStream;\n\n    // Initiate the stream with the remote device\n    const remoteDesc = new RTCSessionDescription({\n      type: \"answer\",\n      sdp: webRtcAnswer.answer,\n    });\n    try {\n      await peerConnection.setRemoteDescription(remoteDesc);\n    } catch (err: any) {\n      this._error = \"Failed to connect WebRTC stream: \" + err.message;\n      peerConnection.close();\n      return;\n    }\n    this._peerConnection = peerConnection;\n  }\n\n  private _cleanUp() {\n    if (this._remoteStream) {\n      this._remoteStream.getTracks().forEach((track) => {\n        track.stop();\n      });\n      this._remoteStream = undefined;\n    }\n    if (this._videoEl) {\n      this._videoEl.removeAttribute(\"src\");\n      this._videoEl.load();\n    }\n    if (this._peerConnection) {\n      this._peerConnection.close();\n      this._peerConnection = undefined;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      video {\n        display: block;\n      }\n\n      video {\n        width: 100%;\n        max-height: var(--video-max-height, calc(100vh - 97px));\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-web-rtc-player\": HaWebRtcPlayer;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { isComponentLoaded } from \"../common/config/is_component_loaded\";\nimport { computeStateName } from \"../common/entity/compute_state_name\";\nimport { supportsFeature } from \"../common/entity/supports-feature\";\nimport {\n  CameraEntity,\n  CAMERA_SUPPORT_STREAM,\n  computeMJPEGStreamUrl,\n  fetchStreamUrl,\n  STREAM_TYPE_HLS,\n  STREAM_TYPE_WEB_RTC,\n} from \"../data/camera\";\nimport { HomeAssistant } from \"../types\";\nimport \"./ha-hls-player\";\nimport \"./ha-web-rtc-player\";\n\n@customElement(\"ha-camera-stream\")\nclass HaCameraStream extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property({ attribute: false }) public stateObj?: CameraEntity;\n\n  @property({ type: Boolean, attribute: \"controls\" })\n  public controls = false;\n\n  @property({ type: Boolean, attribute: \"muted\" })\n  public muted = false;\n\n  @property({ type: Boolean, attribute: \"allow-exoplayer\" })\n  public allowExoPlayer = false;\n\n  // We keep track if we should force MJPEG if there was a failure\n  // to get the HLS stream url. This is reset if we change entities.\n  @state() private _forceMJPEG?: string;\n\n  @state() private _url?: string;\n\n  @state() private _connected = false;\n\n  public willUpdate(changedProps: PropertyValues): void {\n    if (\n      changedProps.has(\"stateObj\") &&\n      !this._shouldRenderMJPEG &&\n      this.stateObj &&\n      (changedProps.get(\"stateObj\") as CameraEntity | undefined)?.entity_id !==\n        this.stateObj.entity_id &&\n      this.stateObj!.attributes.frontend_stream_type === STREAM_TYPE_HLS\n    ) {\n      this._forceMJPEG = undefined;\n      this._url = undefined;\n      this._getStreamUrl();\n    }\n  }\n\n  public connectedCallback() {\n    super.connectedCallback();\n    this._connected = true;\n  }\n\n  public disconnectedCallback() {\n    super.disconnectedCallback();\n    this._connected = false;\n  }\n\n  protected render(): TemplateResult {\n    if (!this.stateObj) {\n      return html``;\n    }\n    if (__DEMO__ || this._shouldRenderMJPEG) {\n      return html` <img\n        .src=${__DEMO__\n          ? this.stateObj.attributes.entity_picture!\n          : this._connected\n          ? computeMJPEGStreamUrl(this.stateObj)\n          : \"\"}\n        .alt=${`Preview of the ${computeStateName(this.stateObj)} camera.`}\n      />`;\n    }\n    if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_HLS) {\n      return this._url\n        ? html`<ha-hls-player\n            autoplay\n            playsinline\n            .allowExoPlayer=${this.allowExoPlayer}\n            .muted=${this.muted}\n            .controls=${this.controls}\n            .hass=${this.hass}\n            .url=${this._url}\n          ></ha-hls-player>`\n        : html``;\n    }\n    if (this.stateObj.attributes.frontend_stream_type === STREAM_TYPE_WEB_RTC) {\n      return html`<ha-web-rtc-player\n        autoplay\n        playsinline\n        .muted=${this.muted}\n        .controls=${this.controls}\n        .hass=${this.hass}\n        .entityid=${this.stateObj.entity_id}\n      ></ha-web-rtc-player>`;\n    }\n    return html``;\n  }\n\n  private get _shouldRenderMJPEG() {\n    if (this._forceMJPEG === this.stateObj!.entity_id) {\n      // Fallback when unable to fetch stream url\n      return true;\n    }\n    if (!supportsFeature(this.stateObj!, CAMERA_SUPPORT_STREAM)) {\n      // Steaming is not supported by the camera so fallback to MJPEG stream\n      return true;\n    }\n    if (\n      this.stateObj!.attributes.frontend_stream_type === STREAM_TYPE_WEB_RTC\n    ) {\n      // Browser support required for WebRTC\n      return typeof RTCPeerConnection === \"undefined\";\n    }\n    // Server side stream component required for HLS\n    return !isComponentLoaded(this.hass!, \"stream\");\n  }\n\n  private async _getStreamUrl(): Promise<void> {\n    try {\n      const { url } = await fetchStreamUrl(\n        this.hass!,\n        this.stateObj!.entity_id\n      );\n\n      this._url = url;\n    } catch (err: any) {\n      // Fails if we were unable to get a stream\n      // eslint-disable-next-line\n      console.error(err);\n\n      this._forceMJPEG = this.stateObj!.entity_id;\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host,\n      img {\n        display: block;\n      }\n\n      img {\n        width: 100%;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-camera-stream\": HaCameraStream;\n  }\n}\n","import {\n  css,\n  CSSResultGroup,\n  html,\n  LitElement,\n  PropertyValues,\n  TemplateResult,\n} from \"lit\";\nimport { customElement, property, state } from \"lit/decorators\";\nimport { classMap } from \"lit/directives/class-map\";\nimport { styleMap } from \"lit/directives/style-map\";\nimport { STATES_OFF } from \"../../../common/const\";\nimport parseAspectRatio from \"../../../common/util/parse-aspect-ratio\";\nimport \"../../../components/ha-camera-stream\";\nimport { CameraEntity, fetchThumbnailUrlWithCache } from \"../../../data/camera\";\nimport { UNAVAILABLE } from \"../../../data/entity\";\nimport { HomeAssistant } from \"../../../types\";\nimport \"../../../components/ha-circular-progress\";\n\nconst UPDATE_INTERVAL = 10000;\nconst DEFAULT_FILTER = \"grayscale(100%)\";\n\nconst MAX_IMAGE_WIDTH = 640;\nconst ASPECT_RATIO_DEFAULT = 9 / 16;\n\nconst enum LoadState {\n  Loading = 1,\n  Loaded = 2,\n  Error = 3,\n}\n\nexport interface StateSpecificConfig {\n  [state: string]: string;\n}\n\n@customElement(\"hui-image\")\nexport class HuiImage extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() public entity?: string;\n\n  @property() public image?: string;\n\n  @property({ attribute: false }) public stateImage?: StateSpecificConfig;\n\n  @property() public cameraImage?: string;\n\n  @property() public cameraView?: \"live\" | \"auto\";\n\n  @property() public aspectRatio?: string;\n\n  @property() public filter?: string;\n\n  @property({ attribute: false }) public stateFilter?: StateSpecificConfig;\n\n  @property() public darkModeImage?: string;\n\n  @property() public darkModeFilter?: string;\n\n  @state() private _imageVisible? = false;\n\n  @state() private _loadState?: LoadState;\n\n  @state() private _cameraImageSrc?: string;\n\n  @state() private _loadedImageSrc?: string;\n\n  private _intersectionObserver?: IntersectionObserver;\n\n  private _lastImageHeight?: number;\n\n  private _cameraUpdater?: number;\n\n  private _ratio: {\n    w: number;\n    h: number;\n  } | null = null;\n\n  public connectedCallback(): void {\n    super.connectedCallback();\n    if (this._loadState === undefined) {\n      this._loadState = LoadState.Loading;\n    }\n    if (this.cameraImage && this.cameraView !== \"live\") {\n      this._startIntersectionObserverOrUpdates();\n    }\n  }\n\n  public disconnectedCallback(): void {\n    super.disconnectedCallback();\n    this._stopUpdateCameraInterval();\n    this._stopIntersectionObserver();\n    this._imageVisible = undefined;\n  }\n\n  protected handleIntersectionCallback(entries: IntersectionObserverEntry[]) {\n    this._imageVisible = entries[0].isIntersecting;\n  }\n\n  public willUpdate(changedProps: PropertyValues): void {\n    if (changedProps.has(\"hass\")) {\n      const oldHass = changedProps.get(\"hass\") as HomeAssistant | undefined;\n\n      if (this._shouldStartCameraUpdates(oldHass)) {\n        this._startIntersectionObserverOrUpdates();\n      } else if (!this.hass!.connected) {\n        this._stopUpdateCameraInterval();\n        this._stopIntersectionObserver();\n        this._loadState = LoadState.Loading;\n        this._cameraImageSrc = undefined;\n        this._loadedImageSrc = undefined;\n      }\n    }\n    if (changedProps.has(\"_imageVisible\")) {\n      if (this._imageVisible) {\n        if (this._shouldStartCameraUpdates()) {\n          this._startUpdateCameraInterval();\n        }\n      } else {\n        this._stopUpdateCameraInterval();\n      }\n    }\n    if (changedProps.has(\"aspectRatio\")) {\n      this._ratio = this.aspectRatio\n        ? parseAspectRatio(this.aspectRatio)\n        : null;\n    }\n    if (this._loadState === LoadState.Loading && !this.cameraImage) {\n      this._loadState = LoadState.Loaded;\n    }\n  }\n\n  protected render(): TemplateResult {\n    if (!this.hass) {\n      return html``;\n    }\n    const useRatio = Boolean(\n      this._ratio && this._ratio.w > 0 && this._ratio.h > 0\n    );\n    const stateObj = this.entity ? this.hass.states[this.entity] : undefined;\n    const entityState = stateObj ? stateObj.state : UNAVAILABLE;\n\n    // Figure out image source to use\n    let imageSrc: string | undefined;\n    let cameraObj: CameraEntity | undefined;\n    // Track if we are we using a fallback image, used for filter.\n    let imageFallback = !this.stateImage;\n\n    if (this.cameraImage) {\n      if (this.cameraView === \"live\") {\n        cameraObj = this.hass.states[this.cameraImage] as CameraEntity;\n      } else {\n        imageSrc = this._cameraImageSrc;\n      }\n    } else if (this.stateImage) {\n      const stateImage = this.stateImage[entityState];\n\n      if (stateImage) {\n        imageSrc = stateImage;\n      } else {\n        imageSrc = this.image;\n        imageFallback = true;\n      }\n    } else if (this.darkModeImage && this.hass.themes.darkMode) {\n      imageSrc = this.darkModeImage;\n    } else {\n      imageSrc = this.image;\n    }\n\n    if (imageSrc) {\n      imageSrc = this.hass.hassUrl(imageSrc);\n    }\n\n    // Figure out filter to use\n    let filter = this.filter || \"\";\n\n    if (this.hass.themes.darkMode && this.darkModeFilter) {\n      filter += this.darkModeFilter;\n    }\n\n    if (this.stateFilter && this.stateFilter[entityState]) {\n      filter += this.stateFilter[entityState];\n    }\n\n    if (!filter && this.entity) {\n      const isOff = !stateObj || STATES_OFF.includes(entityState);\n      filter = isOff && imageFallback ? DEFAULT_FILTER : \"\";\n    }\n\n    return html`\n      <div\n        style=${styleMap({\n          paddingBottom: useRatio\n            ? `${((100 * this._ratio!.h) / this._ratio!.w).toFixed(2)}%`\n            : undefined,\n          backgroundImage:\n            useRatio && this._loadedImageSrc\n              ? `url(\"${this._loadedImageSrc}\")`\n              : undefined,\n          filter:\n            this._loadState === LoadState.Loaded || this.cameraView === \"live\"\n              ? filter\n              : undefined,\n        })}\n        class=\"container ${classMap({\n          ratio: useRatio,\n        })}\"\n      >\n        ${this.cameraImage && this.cameraView === \"live\"\n          ? html`\n              <ha-camera-stream\n                muted\n                .hass=${this.hass}\n                .stateObj=${cameraObj}\n              ></ha-camera-stream>\n            `\n          : imageSrc === undefined\n          ? html``\n          : html`\n              <img\n                id=\"image\"\n                src=${imageSrc}\n                @error=${this._onImageError}\n                @load=${this._onImageLoad}\n                style=${styleMap({\n                  display:\n                    useRatio || this._loadState === LoadState.Loaded\n                      ? \"block\"\n                      : \"none\",\n                })}\n              />\n            `}\n        ${this._loadState === LoadState.Error\n          ? html`<div\n              id=\"brokenImage\"\n              style=${styleMap({\n                height: !useRatio\n                  ? `${this._lastImageHeight || \"100\"}px`\n                  : undefined,\n              })}\n            ></div>`\n          : this.cameraView !== \"live\" &&\n            (imageSrc === undefined || this._loadState === LoadState.Loading)\n          ? html`<div\n              class=\"progress-container\"\n              style=${styleMap({\n                height: !useRatio\n                  ? `${this._lastImageHeight || \"100\"}px`\n                  : undefined,\n              })}\n            >\n              <ha-circular-progress\n                class=\"render-spinner\"\n                active\n                size=\"small\"\n              ></ha-circular-progress>\n            </div>`\n          : \"\"}\n      </div>\n    `;\n  }\n\n  protected _shouldStartCameraUpdates(oldHass?: HomeAssistant): boolean {\n    return !!(\n      (!oldHass || oldHass.connected !== this.hass!.connected) &&\n      this.hass!.connected &&\n      this.cameraView !== \"live\"\n    );\n  }\n\n  private _startIntersectionObserverOrUpdates(): void {\n    if (\"IntersectionObserver\" in window) {\n      if (!this._intersectionObserver) {\n        this._intersectionObserver = new IntersectionObserver(\n          this.handleIntersectionCallback.bind(this)\n        );\n      }\n      this._intersectionObserver.observe(this);\n    } else {\n      // No support for IntersectionObserver\n      // assume all images are visible\n      this._imageVisible = true;\n      this._startUpdateCameraInterval();\n    }\n  }\n\n  private _stopIntersectionObserver(): void {\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n    }\n  }\n\n  private _startUpdateCameraInterval(): void {\n    this._stopUpdateCameraInterval();\n    this._updateCameraImageSrc();\n    if (this.cameraImage && this.isConnected) {\n      this._cameraUpdater = window.setInterval(\n        () => this._updateCameraImageSrcAtInterval(),\n        UPDATE_INTERVAL\n      );\n    }\n  }\n\n  private _stopUpdateCameraInterval(): void {\n    if (this._cameraUpdater) {\n      clearInterval(this._cameraUpdater);\n      this._cameraUpdater = undefined;\n    }\n  }\n\n  private _onImageError(): void {\n    this._loadState = LoadState.Error;\n  }\n\n  private async _onImageLoad(ev: Event): Promise<void> {\n    this._loadState = LoadState.Loaded;\n    const imgEl = ev.target as HTMLImageElement;\n    if (this._ratio && this._ratio.w > 0 && this._ratio.h > 0) {\n      this._loadedImageSrc = imgEl.src;\n    }\n    await this.updateComplete;\n    this._lastImageHeight = imgEl.offsetHeight;\n  }\n\n  private async _updateCameraImageSrcAtInterval(): Promise<void> {\n    // If we hit the interval and it was still loading\n    // it means we timed out so we should show the error.\n    if (this._loadState === LoadState.Loading) {\n      this._onImageError();\n    }\n    return this._updateCameraImageSrc();\n  }\n\n  private async _updateCameraImageSrc(): Promise<void> {\n    if (!this.hass || !this.cameraImage) {\n      return;\n    }\n\n    const cameraState = this.hass.states[this.cameraImage] as\n      | CameraEntity\n      | undefined;\n\n    if (!cameraState) {\n      this._onImageError();\n      return;\n    }\n\n    const element_width = this.clientWidth || MAX_IMAGE_WIDTH;\n    let width = Math.ceil(element_width * devicePixelRatio);\n    let height: number;\n    // If the image has not rendered yet we have no height\n    if (!this._lastImageHeight) {\n      if (this._ratio && this._ratio.w > 0 && this._ratio.h > 0) {\n        height = Math.ceil(width * (this._ratio.h / this._ratio.w));\n      } else {\n        // If we don't have a ratio and we don't have a height\n        // we ask for 200% of what we need because the aspect\n        // ratio might result in a smaller image\n        width *= 2;\n        height = Math.ceil(width * ASPECT_RATIO_DEFAULT);\n      }\n    } else {\n      height = Math.ceil(this._lastImageHeight * devicePixelRatio);\n    }\n    this._cameraImageSrc = await fetchThumbnailUrlWithCache(\n      this.hass,\n      this.cameraImage,\n      width,\n      height\n    );\n    if (this._cameraImageSrc === undefined) {\n      this._onImageError();\n    }\n  }\n\n  static get styles(): CSSResultGroup {\n    return css`\n      :host {\n        display: block;\n      }\n\n      .container {\n        transition: filter 0.2s linear;\n      }\n\n      img {\n        display: block;\n        height: auto;\n        width: 100%;\n      }\n\n      .progress-container {\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n\n      .ratio {\n        position: relative;\n        width: 100%;\n        height: 0;\n        background-position: center;\n        background-size: cover;\n      }\n\n      .ratio img,\n      .ratio div {\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n      }\n\n      .ratio img {\n        visibility: hidden;\n      }\n\n      #brokenImage {\n        background: grey url(\"/static/images/image-broken.svg\") center/36px\n          no-repeat;\n      }\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"hui-image\": HuiImage;\n  }\n}\n"],"names":[],"sourceRoot":""}