from typing import Dict, List, Optional, Tuple
from uuid import UUID

import torch

Shape = Tuple[int, ...]

class EinsumSpec(object):
    input_ints: List[List[int]]
    output_ints: List[int]
    int_sizes: List[int]
    def __init__(self, input_ints: List[List[int]], output_ints: List[int], int_sizes: Dict[int, int]): ...
    def flops(self) -> int: ...
    def optimize_dp(
        self, check_outer: bool, mem_limit: Optional[int], hash_limit: Optional[int]
    ) -> List[List[int]]: ...
    def normalize(self) -> "EinsumSpec": ...
    def validate(self) -> bool: ...
    def shapes(self) -> Tuple[List[List[int]], List[int]]: ...
    def to_einsum_string(self) -> str: ...

class RearrangeSpec(object):
    input_ints: List[List[int]]
    output_ints: List[List[int]]
    int_sizes: List[int]
    def __init__(self, input_ints: List[List[int]], output_ints: List[List[int]], int_sizes: List[int]): ...
    def is_identity(self) -> bool: ...
    def is_permute(self) -> bool: ...
    def shapes(self) -> Tuple[List[int], List[int]]: ...
    def is_valid(self) -> bool: ...
    def to_einops_string(self) -> str: ...
    def to_einops_string_and_letter_sizes(self) -> Tuple[str, List[Tuple[str, int]]]: ...
    def apply(self, tensor: torch.Tensor) -> torch.Tensor: ...

class Circuit:
    @property
    def shape(self) -> Shape: ...
    @property
    def is_constant(self) -> bool: ...
    @property
    def is_explicitly_computable(self) -> bool: ...
    @property
    def can_be_sampled(self) -> bool: ...
    @property
    def name(self) -> str: ...
    def children(self) -> List[Circuit]: ...

class Einsum(Circuit):
    def __init__(
        self, *args: Tuple[Circuit, Tuple[int, ...]], out_axes: Tuple[int, ...], name: Optional[str] = None
    ) -> None: ...
    @property
    def args(self) -> List[Tuple[Circuit, Tuple[int, ...]]]: ...
    @property
    def out_axes(self) -> Tuple[int, ...]: ...

class ArrayConstant(Circuit):
    def __init__(self, value: torch.Tensor, name: str = "ArrayConstant") -> None: ...
    @property
    def uuid(self) -> UUID: ...
    @property
    def value(self) -> torch.Tensor: ...

class Symbol(Circuit):
    def __init__(self, shape: Shape, uuid: UUID, name: str = "Symbol") -> None: ...
    @property
    def uuid(self) -> UUID: ...

class ScalarConstant(Circuit):
    def __init__(self, value: float, name: str = "ScalarConstant") -> None: ...
    @property
    def value(self) -> float: ...
